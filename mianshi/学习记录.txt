1、res/raw和assets两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。
2、== 和equals区别
A.==可用于基本类型和引用类型：当用于基本类型时候，是比较值是否相同；当用于引用类型的时候，是比较对象是否相同。
3、深复制 浅复制
4、序列化和反序列化
Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。

 为什么需要序列化与反序列化（如Intent传递对象 ）

 实现Parcelable或Serializable  Parcelable（安卓专用）的速度比Serializable 高十倍以上
 我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等，
 而这些数据都会以二进制序列的形式在网络上传送。那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？
答案是可以的。如何做到呢？这就需要Java序列化与反序列化了。换句话说，一方面，发送方需要把这个Java对象转换
为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。
类别	synchronized	                                          Lock
存在层次	Java的关键字，在jvm层面上	                是一个类


锁的释放	1、以获取锁的线程执行完同步代码，释放锁
                 2、线程执行发生异常，jvm会让线程释放锁 	在finally中必须释放锁，不然容易造成线程死锁


锁的获取	假设A线程获得锁，B线程等待。如果A线程阻塞，
                B线程会一直等待	                                分情况而定，Lock有多个锁获
                                                                取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待


锁状态	无法判断	                                       可以判断


锁类型	可重入 不可中断 非公平	                               可重入 可判断 可公平（两者皆可）


性能	少量同步	                                       大量同步

查看内存使用状况
adb shell dumpsys meminfo 包名